---
import { calculateCalibrationPoints } from "@lib/calibration";
import type { MarketDetails, PlatformDetails } from "@types";
import SelectableOptions from "./selectable-options.astro";

interface Props {
  plotId: string;
  platforms: PlatformDetails[];
  options: Array<{
    icon?: string | null;
    description: string;
    axisTitleX?: string | null;
    axisTitleY?: string | null;
    markets: MarketDetails[];
    criterion?: string | null;
    weight?: string | null;
  }>;
}
const { plotId, platforms, options } = Astro.props;

const optionsCalculated = await Promise.all(
  options.map(async (opt) => {
    const points = await calculateCalibrationPoints(
      opt.markets,
      opt.criterion || "midpoint",
      opt.weight || null,
    );
    if (points.length == 0) {
      throw new Error(`Calibration points are empty for option ${opt}.`);
    }
    return {
      id: `calibration-option-${Math.random().toString(36).slice(2, 7)}`,
      icon: opt.icon || null,
      description: opt.description,
      axisTitleX: opt.axisTitleX || "Prediction (midpoint)",
      axisTitleY: opt.axisTitleY || "Resolution",
      count: opt.markets.length,
      points: points,
    };
  }),
);
---

<div class="grid gap-2 grid-cols-1 md:grid-cols-3">
  <SelectableOptions
    plotId={plotId}
    optionClass="calibration-option"
    options={optionsCalculated}
  />
  <div class="col-span-2">
    <div
      class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
    >
      <div
        id={`calibration-plot-${plotId}`}
        class="calibration-plot"
        data-platforms={JSON.stringify(platforms)}
        data-options={JSON.stringify(optionsCalculated)}
      >
      </div>
    </div>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { CalibrationOption, CalibrationPoint } from "@lib/charts/types";
  import type { PlatformDetails } from "@types";
  import {
    initSelectableCharts,
    updatePlotElement,
  } from "@lib/charts/selectable-option";

  // Update the given plot when called
  function updatePlot(plotElement: HTMLElement, option: CalibrationOption) {
    const platforms = JSON.parse(
      (plotElement as HTMLElement & { dataset: any }).dataset.platforms,
    ) as PlatformDetails[];

    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);
    const pointSizeRange = [plotWidth * 0.01, plotWidth * 0.02];

    // Build the plot with the selected option data
    const plot = Plot.plot({
      title: option.config?.title || "Calibration Plot",
      width: plotWidth,
      aspectRatio: 2,
      x: {
        domain: option.config?.xDomain || [0, 100],
        percent: true,
        label:
          option.config?.axisTitleX ||
          option.axisTitleX ||
          "Prediction (midpoint)",
      },
      y: {
        domain: option.config?.yDomain || [0, 100],
        grid: true,
        percent: true,
        label: option.config?.axisTitleY || option.axisTitleY || "Resolution",
      },
      r: { range: pointSizeRange, label: "Scale" },
      color: {
        legend: true,
        label: "Platform",
        domain: platforms.map((p) => p.name),
        range: platforms.map((p) => p.color_primary),
      },
      marks: [
        Plot.dot(option.points || [], {
          x: "x_center",
          y: "y_center",
          r: "count",
          fill: "platform_slug",
          stroke: "platform_slug",
          fillOpacity: 0.5,
          channels: {
            Prediction: (i: CalibrationPoint) =>
              (i.x_start * 100).toFixed(0) +
              "-" +
              (i.x_end * 100).toFixed(0) +
              "%",
            Resolution: (i: CalibrationPoint) =>
              (i.y_center * 100).toFixed(1) + "%",
            Markets: "count",
          },
          tip: {
            format: {
              x: null,
              y: null,
              r: null,
            },
          },
        }),
        Plot.line(option.points || [], {
          x: "x_center",
          y: "y_center",
          stroke: "platform_slug",
          strokeOpacity: 0.5,
        }),
        Plot.ruleX([0]),
        Plot.ruleY([0]),
        Plot.lineY(
          [
            { x: 0, y: 0 },
            { x: 1, y: 1 },
          ],
          { x: "x", y: "y" },
        ),
      ],
    });

    updatePlotElement(plotElement, plot as any);
  }

  // Initialize all calibration plots
  document.addEventListener("DOMContentLoaded", () => {
    initSelectableCharts<CalibrationOption>(
      "calibration-plot",
      "calibration-option",
      updatePlot,
      (element) =>
        JSON.parse((element as HTMLElement & { dataset: any }).dataset.options),
    );
  });
</script>
