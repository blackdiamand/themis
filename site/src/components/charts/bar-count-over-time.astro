---
import type { MarketDetails, PlatformDetails } from "@types";

interface Props {
  platforms: PlatformDetails[];
  markets: MarketDetails[];
}
const { platforms, markets } = Astro.props;

export interface DateBarDatapoint {
  platformName: string;
  color: string;
  startXDate: string;
  startXMs: number;
  endXDate: string;
  endXMs: number;
  countClosed: number;
  percentClosed: number;
  countOpen: number;
  percentOpen: number;
}

const numBins = 100;
const minValue = new Date("2021-01-01").getTime();
const maxValue = new Date().getTime();
const binWidth = (maxValue - minValue) / numBins;

const binsClosed: { [seriesName: string]: number[] } = {};
const binsOpen: { [seriesName: string]: number[] } = {};

// Initialize bins for closed markets
markets.forEach((mkt) => {
  const marketCloseTime = new Date(mkt.close_datetime).getTime();
  if (!binsClosed[mkt.platform_slug]) {
    binsClosed[mkt.platform_slug] = Array(numBins).fill(0);
  }
  const binIndexClose = Math.min(
    numBins - 1,
    Math.floor((marketCloseTime - minValue) / binWidth),
  );
  binsClosed[mkt.platform_slug][binIndexClose]++;
});

// Initialize bins for open markets
markets.forEach((mkt) => {
  const marketOpenTime = new Date(mkt.open_datetime).getTime();
  if (!binsOpen[mkt.platform_slug]) {
    binsOpen[mkt.platform_slug] = Array(numBins).fill(0);
  }
  const binIndexOpen = Math.min(
    numBins - 1,
    Math.floor((marketOpenTime - minValue) / binWidth),
  );
  binsOpen[mkt.platform_slug][binIndexOpen]++;
});

const points: DateBarDatapoint[] = [];
for (const [platformSlug, seriesBinsClosed] of Object.entries(binsClosed)) {
  const platformNumItems = markets.filter(
    (mkt) => mkt.platform_slug === platformSlug,
  ).length;

  for (let index = 0; index < numBins; index++) {
    if (seriesBinsClosed[index] > 0 || binsOpen[platformSlug][index] > 0) {
      const startXMs = minValue + index * binWidth;
      const endXMs = startXMs + binWidth;

      const countClosed = seriesBinsClosed[index] * -1;
      const percentClosed = countClosed / platformNumItems;
      const countOpen = binsOpen[platformSlug]?.[index] ?? 0;
      const percentOpen = countOpen / platformNumItems;

      const platformDetails = platforms.find(
        (platform) => platform.slug === platformSlug,
      );
      if (!platformDetails)
        throw new Error(`Series not found: ${platformSlug}`);

      points.push({
        platformName: platformDetails.name,
        color: platformDetails.color_accent,
        startXDate: new Date(startXMs).toISOString(),
        startXMs,
        endXDate: new Date(endXMs).toISOString(),
        endXMs,
        countClosed,
        percentClosed,
        countOpen,
        percentOpen,
      });
    }
  }
}

const optionCalculated = {
  plotTitle: "Market Close Dates",
  axisTitleX: "Date",
  axisTitleY: "Percent",
  points: points,
};
---

<div
  class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
>
  <div
    id="bar-over-time-default"
    data-option={JSON.stringify(optionCalculated)}
  >
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { DateBarDatapoint } from "./bar-count-over-time.astro";

  interface DateBarPlotElement extends HTMLElement {
    dataset: {
      option: string;
    };
  }

  // Get a reference to the plot element using ID
  const plotElement = document.getElementById(
    "bar-over-time-default",
  ) as DateBarPlotElement | null;

  if (plotElement) {
    const option = JSON.parse(plotElement.dataset.option) as {
      description: string;
      plotTitle: string;
      axisTitleX: string;
      axisTitleY: string;
      points: DateBarDatapoint[];
    };
    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: "Market Open and Close Dates",
      subtitle: "Markets opened (positive) and closed (ngeative) over time",
      width: plotWidth,
      marginLeft: 40,
      marginRight: 80,
      x: {
        label: option.axisTitleX,
        type: "utc",
      },
      y: {
        grid: true,
        percent: true,
        label: option.axisTitleY,
      },
      fy: {
        label: "Platform",
      },
      marks: [
        Plot.rectY(option.points, {
          x1: "startXDate",
          x2: "endXDate",
          y: "percentOpen",
          fy: "platformName",
          fill: "color",
          insetLeft: 1,
          insetRight: 1,
        }),
        Plot.rectY(option.points, {
          x1: "startXDate",
          x2: "endXDate",
          y: "percentClosed",
          fy: "platformName",
          fill: "color",
          insetLeft: 1,
          insetRight: 1,
        }),
        Plot.ruleY([0]),
      ],
    });

    // Wipe the existing plot and add the new one
    while (plotElement.firstChild) {
      plotElement.removeChild(plotElement.firstChild);
    }
    plotElement.appendChild(plot);
  }
</script>
