---
import type { MarketDetails, PlatformDetails } from "@types";

interface Props {
  platforms: PlatformDetails[];
  markets: MarketDetails[];
}
const { platforms, markets } = Astro.props;

export interface DateBarDatapoint {
  platformName: string;
  color: string;
  startXDate: string;
  startXMs: number;
  endXDate: string;
  endXMs: number;
  count: number;
  percent: number;
}

const numBins = 100;
const minValue = new Date("2020-01-01").getTime(); // Convert to milliseconds
const maxValue = new Date().getTime(); // Convert to milliseconds
const binWidth = (maxValue - minValue) / numBins; // Now both sides are numbers

// Create a nested array to count bins per series
const bins: { [seriesName: string]: number[] } = {};

markets.forEach((mkt) => {
  const marketCloseTime = new Date(mkt.close_datetime).getTime();
  if (!bins[mkt.platform_slug]) {
    bins[mkt.platform_slug] = Array(numBins).fill(0);
  }
  const binIndex = Math.min(
    numBins - 1,
    Math.floor((marketCloseTime - minValue) / binWidth),
  );
  bins[mkt.platform_slug][binIndex]++;
});

const points: DateBarDatapoint[] = [];
for (const [platformSlug, seriesBins] of Object.entries(bins)) {
  const platformNumItems = markets.filter(
    (mkt) => mkt.platform_slug === platformSlug,
  ).length;
  seriesBins.forEach((count, index) => {
    if (count > 0) {
      const platformDetails = platforms.find(
        (platform) => platform.slug == platformSlug,
      );
      if (!platformDetails)
        throw new Error(`Series not found: ${platformSlug}`);

      const startX = minValue + index * binWidth;
      const endX = startX + binWidth;

      // Convert milliseconds back to Date for plotting
      points.push({
        platformName: platformDetails.name,
        color: platformDetails.color_accent,
        startXDate: new Date(startX).toISOString(),
        startXMs: startX,
        endXDate: new Date(endX).toISOString(),
        endXMs: endX,
        count,
        percent: count / platformNumItems,
      });
    }
  });
}

const optionCalculated = {
  plotTitle: "Market Close Dates",
  axisTitleX: "Date",
  axisTitleY: "Percent",
  points: points,
};
---

<div
  class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
>
  <div
    id="bar-over-time-default"
    data-option={JSON.stringify(optionCalculated)}
  >
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { DateBarDatapoint } from "./bar-count-over-time.astro";

  interface DateBarPlotElement extends HTMLElement {
    dataset: {
      option: string;
    };
  }

  // Get a reference to the plot element using ID
  const plotElement = document.getElementById(
    "bar-over-time-default",
  ) as DateBarPlotElement | null;

  if (plotElement) {
    const option = JSON.parse(plotElement.dataset.option) as {
      description: string;
      plotTitle: string;
      axisTitleX: string;
      axisTitleY: string;
      points: DateBarDatapoint[];
    };
    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: option.plotTitle,
      width: plotWidth,
      marginLeft: 40,
      marginRight: 80,
      x: {
        label: option.axisTitleX,
        type: "utc",
      },
      y: {
        grid: true,
        percent: true,
        label: option.axisTitleY,
      },
      fy: {
        label: "Platform",
      },
      marks: [
        Plot.rectY(option.points, {
          x1: "startXDate",
          x2: "endXDate",
          y: "percent",
          fy: "platformName",
          fill: "color",
          insetLeft: 1,
          insetRight: 1,
          tip: true,
        }),
        Plot.ruleY([0]),
      ],
    });

    // Wipe the existing plot and add the new one
    while (plotElement.firstChild) {
      plotElement.removeChild(plotElement.firstChild);
    }
    plotElement.appendChild(plot);
  }
</script>
