---
import type { MarketScoreDetails, PlatformDetails } from "@types";

import * as Plot from "@observablehq/plot";
import { JSDOM } from "jsdom";
const { document } = new JSDOM().window;

interface Props {
  platforms: PlatformDetails[];
  scores: MarketScoreDetails[];
  width?: number;
  aspectRatio?: number;
  caption?: string;
}
let { platforms, scores, width, aspectRatio, caption } = Astro.props;

// NOTE: Currently only supports brier midpoint and requires all scores to be filtered already

export interface HistogramDatapoint {
  platformName: string;
  startX: number;
  endX: number;
  count: number;
}

const numBins = 20;
const minValue = 0;
const maxValue = 1;
const binWidth = (maxValue - minValue) / numBins;

// Create a nested array to count bins per series
const bins: { [seriesName: string]: number[] } = {};

scores.forEach((s) => {
  if (!bins[s.platform_slug]) {
    bins[s.platform_slug] = Array(numBins).fill(0);
  }
  const binIndex = Math.min(
    numBins - 1,
    Math.floor((s.score - minValue) / binWidth),
  );
  bins[s.platform_slug][binIndex]++;
});

const points: HistogramDatapoint[] = [];
for (const [platformSlug, platformBins] of Object.entries(bins)) {
  platformBins.forEach((count, index) => {
    if (count > 0) {
      const platformInfo = platforms.find((p) => p.slug == platformSlug);
      if (!platformInfo) throw new Error(`Platform not found: ${platformSlug}`);
      const startX = minValue + index * binWidth;
      const endX = startX + binWidth;
      points.push({
        platformName: platformInfo.name,
        startX,
        endX,
        count,
      });
    }
  });
}

// Set default sizes
if (!width) width = 600;

// Generate the plot
const plot = Plot.plot({
  title: "Accuracy Histogram",
  width: width,
  aspectRatio: aspectRatio,
  marginLeft: 50,
  x: { label: "Midpoint Brier score" },
  y: {
    grid: true,
    label: "Count",
  },
  color: {
    legend: platforms.length > 1,
    label: "Platform",
    domain: platforms.map((p) => p.name),
    range: platforms.map((p) => p.color_primary),
  },
  marks: [
    Plot.rectY(points, {
      x1: "startX",
      x2: "endX",
      y: "count",
      fill: "platformName",
      insetLeft: 1,
      insetRight: 1,
    }),
  ],
  document,
}).outerHTML;
---

<div
  class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
>
  <Fragment set:html={plot} />
  <p class="text-xs">
    {caption}
  </p>
  <p class="text-xs">
    Source: <a href="https://predictionmetrics.org">predictionmetrics.org</a>
  </p>
</div>
