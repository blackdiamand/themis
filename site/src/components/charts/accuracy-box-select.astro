---
import type { MarketScoreDetails, PlatformDetails } from "@types";
import { Icon } from "astro-icon/components";

interface Props {
  plotId: string;
  platforms: PlatformDetails[];
  marketScores: MarketScoreDetails[];
  options: Array<{
    icon?: string | null;
    description: string;
    score_type: string;
  }>;
}
const { plotId, platforms, marketScores, options } = Astro.props;

export interface AccuracyBoxDatapoint {
  platformName: string;
  colorPrimary: string;
  colorAccent: string;
  whiskerStart: number;
  boxStart: number;
  boxCenter: number;
  boxEnd: number;
  whiskerEnd: number;
}

function getPercentile(arr: MarketScoreDetails[], percentile: number): number {
  // assumes the scores are pre-sorted
  const index = percentile * (arr.length - 1);

  if (Number.isInteger(index)) {
    return arr[index].score;
  } else {
    // interpolate to get percentile between points
    const lowerIndex = Math.floor(index);
    const upperIndex = Math.ceil(index);
    return (
      arr[lowerIndex].score +
      (index - lowerIndex) * (arr[upperIndex].score - arr[lowerIndex].score)
    );
  }
}

function getAccBoxPoint(
  platform: PlatformDetails,
  score_type: string,
  scores: MarketScoreDetails[],
): AccuracyBoxDatapoint {
  const filteredScores = marketScores.filter(
    (ms) => ms.platform_slug == platform.slug && ms.score_type == score_type,
  );
  const numScores = filteredScores.length;
  const min = filteredScores[0].score;
  const q1 = getPercentile(filteredScores, 0.25);
  const median = getPercentile(filteredScores, 0.5);
  const q3 = getPercentile(filteredScores, 0.75);
  const max = filteredScores[numScores - 1].score;
  const iqr = q3 - q1;
  const whiskerStart = Math.max(q1 - 1.5 * iqr, min);
  const whiskerEnd = Math.min(q3 + 1.5 * iqr, max);
  return {
    platformName: platform.name,
    colorPrimary: platform.color_primary,
    colorAccent: platform.color_accent,
    whiskerStart: whiskerStart,
    boxStart: q1,
    boxCenter: median,
    boxEnd: q3,
    whiskerEnd: whiskerEnd,
  };
}

const optionsCalculated = options.map((opt) => {
  const points: AccuracyBoxDatapoint[] = platforms.map((platform) =>
    getAccBoxPoint(platform, opt.score_type, marketScores),
  );
  return {
    icon: opt.icon,
    description: opt.description,
    numMarkets: 0,
    points: points,
  };
});
---

<div class="grid gap-2 grid-cols-1 md:grid-cols-3">
  <div class="flex-col space-y-2">
    {
      optionsCalculated.map((opt, index) => (
        <div class="bg-base-light text-crust rounded-md drop-shadow-sm px-4 py-2">
          <div class="flex items-center">
            <input
              type="radio"
              id={`accuracy-option-${plotId}-${index}`}
              name={`accuracy-option-${plotId}`}
              value={index}
              class={`w-5 h-5 mr-4 text-mantle accuracy-option-${plotId}`}
            />
            <label for={`accuracy-option-${plotId}-${index}`} class="w-full">
              <span>
                {opt.icon && <Icon name={opt.icon} class="inline mb-1 mr-1" />}
                {opt.description}
              </span>
              <div class="text-xs text-right">
                n={opt.numMarkets.toLocaleString()}
              </div>
            </label>
          </div>
        </div>
      ))
    }
  </div>
  <div class="col-span-2">
    <div
      class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
    >
      <div
        id="accuracy-plot-default"
        data-options={JSON.stringify(optionsCalculated)}
      >
      </div>
    </div>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { AccuracyBoxDatapoint } from "./accuracy-box-select.astro";

  interface AccuracyPlotElement extends HTMLElement {
    dataset: {
      options: string;
    };
  }
  interface OptionData {
    points: AccuracyBoxDatapoint[];
  }

  // Get a reference to the plot element using ID
  const plotElement = document.getElementById(
    "accuracy-plot-default",
  ) as AccuracyPlotElement | null;

  if (plotElement) {
    const options = JSON.parse(plotElement.dataset.options) as OptionData[];
    const points = options[0].points;

    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: "Accuracy By Platform",
      width: plotWidth,
      //aspectRatio: 2,
      x: { label: "Platform" },
      y: { domain: [0, 1], grid: true, label: "Score" },
      marks: [
        Plot.ruleX(points, {
          x: "platformName",
          y1: "whiskerStart",
          y2: "boxStart",
          stroke: "colorAccent",
        }),
        Plot.barY(points, {
          x: "platformName",
          y1: "boxStart",
          y2: "boxEnd",
          fill: "colorPrimary",
          stroke: "colorAccent",
          strokeWidth: 2,
        }),
        Plot.ruleX(points, {
          x: "platformName",
          y1: "boxEnd",
          y2: "whiskerEnd",
          stroke: "colorAccent",
        }),
        Plot.tickY(points, {
          x: "platformName",
          y: "boxCenter",
          stroke: "colorAccent",
          strokeWidth: 2,
        }),
      ],
    });

    plotElement.append(plot);
  } else {
    throw new Error("Could not find plot element.");
  }
</script>
