---
import type { MarketScoreDetails, PlatformDetails } from "@types";
import { quartiles } from "@lib/stats";
import { Icon } from "astro-icon/components";

interface Props {
  plotId: string;
  platforms: PlatformDetails[];
  options: Array<{
    icon?: string | null;
    description: string;
    scores: MarketScoreDetails[];
    scoreType?: string | null;
    axisTitleX?: string | null;
    axisTitleY?: string | null;
    plotRangeStart?: number | null;
    plotRangeEnd?: number | null;
  }>;
}
const { plotId, platforms, options } = Astro.props;

export interface AccuracyBoxDatapoint {
  platformName: string;
  colorPrimary: string;
  colorAccent: string;
  whiskerStart: number;
  boxStart: number;
  boxCenter: number;
  boxEnd: number;
  whiskerEnd: number;
}

const optionsCalculated = options.map((option) => {
  const scoreType = option.scoreType || "brier-midpoint";
  const filteredScoresType = option.scores.filter(
    (ms) => ms.score_type == scoreType,
  );

  const platformPoints: AccuracyBoxDatapoint[] = platforms.reduce<
    AccuracyBoxDatapoint[]
  >((acc, platform) => {
    const filteredScoresPlatform = filteredScoresType.filter(
      (ms) => ms.platform_slug == platform.slug,
    );
    if (filteredScoresPlatform.length === 0) {
      return acc;
    }
    const scores = filteredScoresPlatform.map((s) => s.score);
    const { c1, q1, q2, q3, c3 } = quartiles(scores);
    acc.push({
      platformName: platform.name,
      colorPrimary: platform.color_primary,
      colorAccent: platform.color_accent,
      whiskerStart: c1,
      boxStart: q1,
      boxCenter: q2,
      boxEnd: q3,
      whiskerEnd: c3,
    });
    return acc;
  }, []);

  let plotRange = [];
  if (option.plotRangeEnd == null) {
    plotRange = [option.plotRangeStart || 0, 0.8];
  } else {
    plotRange = [option.plotRangeStart || 0, option.plotRangeEnd];
  }
  return {
    icon: option.icon,
    description: option.description,
    numMarkets: filteredScoresType.length,
    axisTitleX: option.axisTitleX || "Platform",
    axisTitleY: option.axisTitleY || "Market score",
    plotRangeY: plotRange,
    points: platformPoints,
  };
});
---

<div class="grid gap-2 grid-cols-1 md:grid-cols-3">
  <div class="flex-col space-y-2">
    {
      optionsCalculated.map((opt, index) => (
        <div class="bg-base-light text-crust rounded-md drop-shadow-sm px-4 py-2">
          <div class="flex items-center">
            <input
              type="radio"
              id={`accuracy-option-${plotId}-${index}`}
              name={`accuracy-option-${plotId}`}
              value={index}
              class={`w-5 h-5 mr-4 text-mantle accuracy-option-${plotId}`}
            />
            <label for={`accuracy-option-${plotId}-${index}`} class="w-full">
              <span>
                {opt.icon && <Icon name={opt.icon} class="inline mb-1 mr-1" />}
                {opt.description}
              </span>
              <div class="text-xs text-right">
                n={opt.numMarkets.toLocaleString()}
              </div>
            </label>
          </div>
        </div>
      ))
    }
  </div>
  <div class="col-span-2">
    <div
      class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
    >
      <div
        id={`accuracy-plot-${plotId}`}
        class="accuracy-plot"
        data-options={JSON.stringify(optionsCalculated)}
      >
      </div>
    </div>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { AccuracyBoxDatapoint } from "./accuracy-box-select.astro";
  import { updatePlotElement } from "@lib/charts/chart-manager";

  interface AccuracyPlotElement extends HTMLElement {
    dataset: {
      options: string;
      [key: string]: string;
    };
  }
  interface OptionData {
    description: string;
    axisTitleX: string;
    axisTitleY: string;
    plotRangeY: number[];
    points: AccuracyBoxDatapoint[];
  }

  // Update the given plot when called
  function updatePlot(plotElement: AccuracyPlotElement, option: OptionData) {
    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: "Accuracy By Platform",
      width: plotWidth,
      //aspectRatio: 2,
      x: { label: option.axisTitleX },
      y: {
        domain: option.plotRangeY,
        grid: true,
        label: option.axisTitleY,
      },
      marks: [
        Plot.ruleX(option.points, {
          x: "platformName",
          y1: "whiskerStart",
          y2: "boxStart",
          stroke: "colorAccent",
        }),
        Plot.barY(option.points, {
          x: "platformName",
          y1: "boxStart",
          y2: "boxEnd",
          fill: "colorPrimary",
          stroke: "colorAccent",
          strokeWidth: 2,
        }),
        Plot.ruleX(option.points, {
          x: "platformName",
          y1: "boxEnd",
          y2: "whiskerEnd",
          stroke: "colorAccent",
        }),
        Plot.tickY(option.points, {
          x: "platformName",
          y: "boxCenter",
          stroke: "colorAccent",
          strokeWidth: 2,
          channels: {
            Point: () => "Median",
          },
          tip: true,
        }),
      ],
    });

    updatePlotElement(plotElement, plot);
  }

  // Initialize all accuracy plots
  document.addEventListener("DOMContentLoaded", () => {
    const plotElements = document.querySelectorAll(".accuracy-plot");
    if (plotElements.length === 0) return;
    
    // For each plotId, initialize selection
    const plotIds = new Set<string>();
    plotElements.forEach(element => {
      const idMatch = element.id.match(/accuracy-plot-(.*)$/);
      if (idMatch && idMatch[1]) {
        plotIds.add(idMatch[1]);
      }
    });
    
    plotIds.forEach(plotId => {
      // Get all matching plot elements
      const plotElements = document.querySelectorAll(
        `.accuracy-plot`,
      ) as NodeListOf<AccuracyPlotElement>;
      
      // Find the specific plot element for this plotId
      plotElements.forEach((plotElement) => {
        if (!plotElement.id.includes(plotId)) return;
        
        // Extract options
        const options = JSON.parse(plotElement.dataset.options) as OptionData[];
        
        // Find options that match the plot ID
        const radios = [
          ...document.querySelectorAll(`.accuracy-option-${plotId}`),
        ] as HTMLInputElement[];
        
        // Set the first radio button to checked by default
        if (radios.length > 0) {
          radios[0].checked = true;
        }
        
        // Update the plot with initial values
        const selectedOption = radios.findIndex(r => r.checked) >= 0 
          ? options[radios.findIndex(r => r.checked)]
          : options[0];
          
        updatePlot(plotElement, selectedOption);
        
        // Set the callbacks for future changes
        radios.forEach((radio, index) => {
          radio.addEventListener("change", () => {
            if (radio.checked) {
              updatePlot(plotElement, options[index]);
            }
          });
        });
      });
    });
  });
</script>
