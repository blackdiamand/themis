---
import type { MarketScoreDetails, PlatformDetails } from "@types";

interface Props {
  platforms: PlatformDetails[];
  marketScores: MarketScoreDetails[];
}
const { platforms, marketScores } = Astro.props;

const filter = {
  score_type: "brier-midpoint",
};
// pre-sort scores for easier percentile calculations
const sortedScores = [...marketScores].sort((a, b) => a.score - b.score);

export interface AccuracyDatapoint {
  platform: string;
  colorPrimary: string;
  colorAccent: string;
  whiskerStart: number;
  boxStart: number;
  boxCenter: number;
  boxEnd: number;
  whiskerEnd: number;
}

function getPercentile(arr: MarketScoreDetails[], percentile: number): number {
  const index = percentile * (arr.length - 1);

  if (Number.isInteger(index)) {
    return arr[index].score;
  } else {
    // interpolate to get percentile between points
    const lowerIndex = Math.floor(index);
    const upperIndex = Math.ceil(index);
    return (
      arr[lowerIndex].score +
      (index - lowerIndex) * (arr[upperIndex].score - arr[lowerIndex].score)
    );
  }
}

const points: AccuracyDatapoint[] = platforms.map((p) => {
  const filteredScores = sortedScores.filter(
    (ms) => ms.platform_slug == p.slug && ms.score_type == filter.score_type,
  );
  const numScores = filteredScores.length;
  const min = filteredScores[0].score;
  const q1 = getPercentile(filteredScores, 0.25);
  const median = getPercentile(filteredScores, 0.5);
  const q3 = getPercentile(filteredScores, 0.75);
  const max = filteredScores[numScores - 1].score;
  const iqr = q3 - q1;
  const whiskerStart = Math.max(q1 - 1.5 * iqr, min);
  const whiskerEnd = Math.min(q3 + 1.5 * iqr, max);
  return {
    platform: p.name,
    colorPrimary: p.color_primary,
    colorAccent: p.color_accent,
    whiskerStart: whiskerStart,
    boxStart: q1,
    boxCenter: median,
    boxEnd: q3,
    whiskerEnd: whiskerEnd,
  };
});
//console.log(points);
---

<div
  class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
>
  <div
    id="accuracy-plot-default"
    data-platforms={JSON.stringify(platforms)}
    data-points={JSON.stringify(points)}
  >
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { CalibrationPoint, PlatformDetails } from "@types";
  import type { AccuracyDatapoint } from "./accuracy-box-select.astro";

  interface CalibrationPlotElement extends HTMLElement {
    dataset: {
      platforms: string;
      points: string;
    };
  }

  // Get a reference to the plot element using ID
  const plotElement = document.getElementById(
    "accuracy-plot-default",
  ) as CalibrationPlotElement | null;

  if (plotElement) {
    const platforms = JSON.parse(
      plotElement.dataset.platforms,
    ) as PlatformDetails[];
    const points = JSON.parse(
      plotElement.dataset.points,
    ) as AccuracyDatapoint[];

    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: "Accuracy By Platform",
      width: plotWidth,
      //aspectRatio: 2,
      x: { label: "Platform" },
      y: { domain: [0, 1], grid: true, label: "Score" },
      marks: [
        Plot.ruleX(points, {
          x: "platform",
          y1: "whiskerStart",
          y2: "boxStart",
          stroke: "colorAccent",
        }),
        Plot.barY(points, {
          x: "platform",
          y1: "boxStart",
          y2: "boxEnd",
          fill: "colorPrimary",
          stroke: "colorAccent",
          strokeWidth: 2,
        }),
        Plot.ruleX(points, {
          x: "platform",
          y1: "boxEnd",
          y2: "whiskerEnd",
          stroke: "colorAccent",
        }),
        Plot.tickY(points, {
          x: "platform",
          y: "boxCenter",
          stroke: "colorAccent",
          strokeWidth: 2,
        }),
      ],
    });

    plotElement.append(plot);
  } else {
    throw new Error("Could not find plot element.");
  }
</script>
