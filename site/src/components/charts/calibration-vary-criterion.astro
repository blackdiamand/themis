---
import { getMarkets, getPlatforms, getCategories } from "@lib/api";
import { calculateCalibrationPoints } from "@lib/calibration";
import { Icon } from "astro-icon/components";

// Download markets and platforms
const markets = await getMarkets();
const platforms = await getPlatforms();

// Filters and descriptions
const filtersInput = [
  {
    description: "Probability at midpoint (default)",
    axisTitle: "Midpoint",
    criterion: "midpoint",
    markets: markets,
  },
  {
    description: "Time-weighted average probability",
    axisTitle: "Average",
    criterion: "time-average",
    markets: markets,
  },
  {
    description: "Probability 24 hours before resolution",
    axisTitle: "24h before resolution",
    criterion: "before-close-hours-24",
    markets: markets.filter((market) => market.duration_days > 30),
  },
  {
    description: "Probability 30 days before resolution",
    axisTitle: "30d before resolution",
    criterion: "before-close-days-30",
    markets: markets.filter((market) => market.duration_days > 30),
  },
  {
    description: "Probability 90 days before resolution",
    axisTitle: "90d before resolution",
    criterion: "before-close-days-90",
    markets: markets.filter((market) => market.duration_days > 90),
  },
  {
    description: "Probability 365 days before resolution",
    axisTitle: "one year before resolution",
    criterion: "before-close-days-365",
    markets: markets.filter((market) => market.duration_days > 365),
  },
  {
    description: "Probability 24 hours after open",
    axisTitle: "24h after open",
    criterion: "before-close-hours-24",
    markets: markets.filter((market) => market.duration_days > 30),
  },
];
const filtersOutput = filtersInput.map((filter) => ({
  description: filter.description,
  axisTitle: filter.axisTitle,
  numMarkets: filter.markets.length,
  points: calculateCalibrationPoints(filter.markets, filter.criterion),
}));
---

<div class="grid gap-2 grid-cols-1 md:grid-cols-3">
  <div class="flex-col space-y-2">
    {
      filtersOutput.map((filter, index) => (
        <div class="bg-base-light text-crust rounded-md drop-shadow-sm px-4 py-2">
          <div class="flex items-center">
            <input
              type="radio"
              id={`filter-criterion-${index}`}
              name="filter-criterion"
              value={index}
              class="w-5 h-5 mr-4 text-mantle"
            />
            <label for={`filter-criterion-${index}`} class="w-full">
              <span>{filter.description}</span>
              <div class="text-xs text-right">
                n={filter.numMarkets.toLocaleString()}
              </div>
            </label>
          </div>
        </div>
      ))
    }
  </div>
  <div class="col-span-2">
    <div
      class="bg-base-light [&_h2]:text-2xl text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
    >
      <div
        id="calibration-plot-vary-criterion"
        data-platforms={JSON.stringify(platforms)}
        data-filters={JSON.stringify(filtersOutput)}
      >
      </div>
    </div>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { CalibrationPoint, PlatformDetails } from "@types";

  interface CalibrationPlotElement extends HTMLElement {
    dataset: {
      platforms: string;
      filters: string;
    };
  }
  interface FilterStruct {
    description: string;
    axisTitle: string;
    numMakrets: number;
    points: CalibrationPoint[];
  }

  // Get a reference to the plot element using ID
  const plotElement = document.getElementById(
    "calibration-plot-vary-criterion",
  ) as CalibrationPlotElement | null;
  if (!plotElement) {
    throw new Error("Could not find plot element.");
  }

  // Get data embedded in plot element
  const platforms = JSON.parse(
    plotElement.dataset.platforms,
  ) as PlatformDetails[];
  const filters = JSON.parse(plotElement.dataset.filters) as FilterStruct[];
  const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

  // Add listeners to update plot on change in selection
  let filterSelectedIndex: number = 0;
  const radios = document.querySelectorAll("input[name='filter-criterion']");
  radios.forEach((radio) => {
    radio.addEventListener("change", async (event) => {
      const targetElement = event.target as HTMLInputElement;
      const newValue = parseInt(targetElement.value);
      if (!isNaN(newValue)) {
        const currentIndex = newValue;
        filterSelectedIndex = currentIndex;
        updatePlot();
      }
    });
  });

  // Update plot when called
  let points = [];
  function updatePlot() {
    if (!plotElement) {
      throw new Error("Could not find plot element.");
    }
    points = filters[filterSelectedIndex].points;
    if (points.length == 0) {
      throw new Error("Points are empty.");
    }

    // Build the plot
    const plot = Plot.plot({
      title: "Calibration Plot",
      width: plotWidth,
      aspectRatio: 2,
      x: {
        domain: [0, 100],
        percent: true,
        label: `Prediction (${filters[filterSelectedIndex].axisTitle})`,
      },
      y: { domain: [0, 100], grid: true, percent: true, label: "Resolution" },
      r: { range: [8, 15], label: "Scale" },
      color: {
        legend: true,
        label: "Platform",
        domain: platforms.map((p) => p.name),
        range: platforms.map((p) => p.color_primary),
      },
      marks: [
        Plot.dot(points, {
          x: "x_center",
          y: "y_center",
          r: "count",
          fill: "platform_slug",
          stroke: "platform_slug",
          fillOpacity: 0.5,
          channels: {
            criterion: (i: CalibrationPoint) =>
              (i.x_start * 100).toFixed(0) +
              "-" +
              (i.x_end * 100).toFixed(0) +
              "%",
            Resolution: (i: CalibrationPoint) =>
              (i.y_center * 100).toFixed(1) + "%",
            Markets: "count",
          },
          tip: {
            format: {
              x: null,
              y: null,
              r: null,
            },
          },
        }),
        Plot.ruleX([0]),
        Plot.ruleY([0]),
        Plot.lineY(
          [
            { x: 0, y: 0 },
            { x: 1, y: 1 },
          ],
          { x: "x", y: "y" },
        ),
      ],
    });

    // Remove existing plot
    while (plotElement.firstChild) {
      plotElement.removeChild(plotElement.firstChild);
    }
    plotElement.appendChild(plot);
    console.log(plot);
  }

  // Initial render with default values
  updatePlot();
</script>
