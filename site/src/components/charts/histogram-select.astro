---
import type { PlatformDetails } from "@types";
import { quartiles, roundSF } from "@lib/stats";
import { Icon } from "astro-icon/components";

interface Props {
  plotId: string;
  platforms: PlatformDetails[];
  options: Array<{
    icon?: string | null;
    description: string;
    items: Array<{
      value: number;
      platformSlug: string;
    }>;
    plotTitle: string;
    axisTitleX: string;
    axisTitleY?: string | null;
    rangeStart?: number | null;
    rangeEnd?: number;
  }>;
}
const { plotId, platforms, options } = Astro.props;

export interface HistogramDatapoint {
  platformName: string;
  colorPrimary: string;
  colorAccent: string;
  startX: number;
  endX: number;
  count: number;
  percent: number;
}

const numBins = 20;
const optionsCalculated = options.map((option) => {
  const items = option.items;
  const valuesSorted = items.map((item) => item.value).sort((a, b) => a - b);
  const { c9 } = quartiles(valuesSorted);
  const c9Rounded = roundSF(c9, 2);

  const rangeStart = option.rangeStart || 0;
  const rangeEnd = option.rangeEnd || c9Rounded;
  const binWidth = (rangeEnd - rangeStart) / numBins;

  // Create a nested array to count bins per platform
  const bins: { [platformSlug: string]: number[] } = {};

  const itemsInRange = items.filter(
    (i) => i.value >= rangeStart && i.value <= rangeEnd,
  );

  itemsInRange.forEach((i) => {
    if (!bins[i.platformSlug]) {
      bins[i.platformSlug] = Array(numBins).fill(0);
    }
    const binIndex = Math.min(
      numBins - 1,
      Math.floor((i.value - rangeStart) / binWidth),
    );
    bins[i.platformSlug][binIndex]++;
  });

  const points: HistogramDatapoint[] = [];
  for (const [platformSlug, platformBins] of Object.entries(bins)) {
    const platformDetails = platforms.find((p) => p.slug === platformSlug);
    if (!platformDetails)
      throw new Error(`Platform not found: ${platformSlug}`);
    const platformNumItems = itemsInRange.filter(
      (v) => v.platformSlug === platformSlug,
    ).length;

    platformBins.forEach((count, index) => {
      if (count > 0) {
        const startX = rangeStart + index * binWidth;
        const endX = startX + binWidth;
        points.push({
          platformName: platformDetails.name,
          colorPrimary: platformDetails.color_primary,
          colorAccent: platformDetails.color_accent,
          startX,
          endX,
          count,
          percent: count / platformNumItems,
        });
      }
    });
  }

  return {
    icon: option.icon,
    description: option.description,
    count: itemsInRange.length,
    plotTitle: option.plotTitle,
    axisTitleX: option.axisTitleX,
    axisTitleY: option.axisTitleY || "Count",
    points: points,
  };
});
---

<div class="grid gap-2 grid-cols-1 md:grid-cols-3">
  <div class="flex-col space-y-2">
    {
      optionsCalculated.map((opt, index) => (
        <div class="bg-base-light text-crust rounded-md drop-shadow-sm px-4 py-2">
          <div class="flex items-center">
            <input
              type="radio"
              id={`histogram-option-${plotId}-${index}`}
              name={`histogram-option-${plotId}`}
              value={index}
              class={`w-5 h-5 mr-4 text-mantle histogram-option-${plotId}`}
            />
            <label for={`histogram-option-${plotId}-${index}`} class="w-full">
              <span>
                {opt.icon && <Icon name={opt.icon} class="inline mb-1 mr-1" />}
                {opt.description}
              </span>
              <div class="text-xs text-right">
                n={opt.count.toLocaleString()}
              </div>
            </label>
          </div>
        </div>
      ))
    }
  </div>
  <div class="col-span-2">
    <div
      class="bg-base-light [&_h2]:text-2xl [&_figcaption]:text-xs text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
    >
      <div
        id={`histogram-plot-${plotId}`}
        class="histogram-plot"
        data-platforms={JSON.stringify(platforms)}
        data-options={JSON.stringify(optionsCalculated)}
      >
      </div>
    </div>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import type { HistogramDatapoint } from "./histogram-select.astro";
  import type { PlatformDetails } from "@types";
  import { initializeChartSelection, updatePlotElement, type ChartElement } from "@lib/charts/chart-manager";

  interface HistogramPlotElement extends ChartElement {
    dataset: {
      platforms: string;
      options: string;
    };
  }
  interface OptionData {
    description: string;
    plotTitle: string;
    axisTitleX: string;
    axisTitleY: string;
    points: HistogramDatapoint[];
  }

  // Update the given plot when called
  function updatePlot(plotElement: HistogramPlotElement, option: OptionData) {
    const platforms = JSON.parse(
      plotElement.dataset.platforms,
    ) as PlatformDetails[];
    const plotWidth = parseInt(window.getComputedStyle(plotElement).width);

    const plot = Plot.plot({
      title: option.plotTitle,
      width: plotWidth,
      //aspectRatio: 2,
      marginLeft: 50,
      marginRight: 80,
      x: { label: option.axisTitleX },
      y: {
        grid: true,
        percent: true,
        label: "Percent",
      },
      fy: {
        label: "Platform",
        axis: null,
      },
      color: {
        label: null,
      },
      marks: [
        Plot.rectY(option.points, {
          x1: "startX",
          x2: "endX",
          y: "percent",
          fy: "platformName",
          fill: "colorAccent",
          insetLeft: 1,
          insetRight: 1,
          tip: true,
        }),
        Plot.ruleY([0]),
      ],
    });

    updatePlotElement(plotElement, plot);
  }

  // Initialize all histogram plots
  document.addEventListener("DOMContentLoaded", () => {
    const plotElements = document.querySelectorAll(".histogram-plot");
    if (plotElements.length === 0) return;
    
    // For each plotId, initialize selection
    const plotIds = new Set<string>();
    plotElements.forEach(element => {
      const idMatch = element.id.match(/histogram-plot-(.*)$/);
      if (idMatch && idMatch[1]) {
        plotIds.add(idMatch[1]);
      }
    });
    
    plotIds.forEach(plotId => {
      initializeChartSelection<OptionData, HistogramPlotElement>(
        plotId,
        "histogram-plot",
        "histogram-option",
        updatePlot
      );
    });
  });
</script>
