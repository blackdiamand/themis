---
import type { CalibrationPoint } from "@types";
import { getMarkets } from "@lib/api";

interface Props {
  title: string;
  subtitle: string;
}
const { title, subtitle } = Astro.props;

// Generate a unique ID for each instance
const uniqueId = `plot-${Math.random().toString(36).substring(2, 9)}`;

// Download markets
const markets = await getMarkets();

// Define types for our data structures
type PlatformData = {
  sum: number;
  count: number;
};

type Bucket = {
  x_start: number;
  x_center: number;
  x_end: number;
  platforms: {
    [key: string]: PlatformData;
  };
};

// Create buckets with width 0.05 from 0 to 1
const bucketWidth = 0.05;
const buckets: Bucket[] = [];

for (let i = 0; i < 1; i += bucketWidth) {
  buckets.push({
    x_start: i,
    x_center: i + bucketWidth / 2,
    x_end: i + bucketWidth,
    platforms: {
      Manifold: { sum: 0, count: 0 },
      Kalshi: { sum: 0, count: 0 },
      Metaculus: { sum: 0, count: 0 },
      Polymarket: { sum: 0, count: 0 },
    },
  });
}

// Categorize markets into buckets by market.prob_at_midpoint and market.platform_slug
markets.forEach((market) => {
  if (market.prob_at_midpoint !== null && market.resolution !== null) {
    const probability = market.prob_at_midpoint;
    const bucketIndex = Math.min(
      Math.floor(probability / bucketWidth),
      buckets.length - 1,
    );
    const platformName =
      market.platform_slug.charAt(0).toUpperCase() +
      market.platform_slug.slice(1);

    if (buckets[bucketIndex].platforms[platformName]) {
      buckets[bucketIndex].platforms[platformName].sum += market.resolution;
      buckets[bucketIndex].platforms[platformName].count += 1;
    }
  }
});

// Create points where y_center is average of market.resolution for all markets in that bucket
let points: CalibrationPoint[] = [];
buckets.forEach((bucket) => {
  Object.entries(bucket.platforms).forEach(([platform, data]) => {
    if (data.count > 0) {
      points.push({
        platform_slug: platform,
        x_start: bucket.x_start,
        x_center: bucket.x_center,
        x_end: bucket.x_end,
        y_start: null,
        y_center: data.sum / data.count,
        y_end: null,
        count: data.count,
      });
    }
  });
});
---

<div
  class="bg-base-light [&_h2]:text-2xl text-crust rounded-md drop-shadow-sm p-4 overflow-x-auto"
>
  <div
    id={uniqueId}
    class="calibration-plot"
    data-title={title}
    data-subtitle={subtitle}
    data-points={JSON.stringify(points)}
  >
  </div>
</div>

<script>
  // @ts-nocheck
  import * as Plot from "@observablehq/plot";

  // Initialize all plots on the page
  document.querySelectorAll(".calibration-plot").forEach((plotElement) => {
    const title = plotElement?.dataset.title || "";
    const subtitle = plotElement?.dataset.subtitle || "";
    const points = JSON.parse(plotElement?.dataset.points || "[]");

    const plot = Plot.plot({
      title: title,
      subtitle: subtitle,
      width: 1200,
      height: 600,
      x: {
        domain: [0, 100],
        percent: true,
        label: "Prediction (Midpoint)",
      },
      y: {
        domain: [0, 100],
        grid: true,
        percent: true,
        label: "Resolution",
      },
      r: { range: [10, 20], label: "Scale" },
      color: {
        legend: true,
        label: "Platform",
        domain: ["Manifold", "Kalshi", "Metaculus", "Polymarket"],
        range: ["#4337c9", "#00d298", "#283441", "#0072f9"],
      },
      marks: [
        Plot.dot(points, {
          x: "x_center",
          y: "y_center",
          r: "count",
          fill: "platform_slug",
          stroke: "platform_slug",
          fillOpacity: 0.5,
          channels: {
            Prediction: (i) =>
              (i.x_start * 100).toFixed(0) +
              "-" +
              (i.x_end * 100).toFixed(0) +
              "%",
            Resolution: (i) => (i.y_center * 100).toFixed(1) + "%",
            Markets: "count",
          },
          tip: {
            format: {
              x: null,
              y: null,
              r: null,
            },
          },
        }),
        Plot.ruleX([0]),
        Plot.ruleY([0]),
        Plot.lineY(
          [
            { x: 0, y: 0 },
            { x: 1, y: 1 },
          ],
          { x: "x", y: "y" },
        ),
      ],
    });

    plotElement.append(plot);
  });
</script>
