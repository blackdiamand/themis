---
import Base from "@layouts/base.astro";
import CalibrationBase from "@components/charts/calibration-base.astro";
import CalibrationVarySelection from "@components/charts/calibration-vary-selection.astro";
import CalibrationVaryCategory from "@components/charts/calibration-vary-category.astro";
import CalibrationVaryPrediction from "@components/charts/calibration-vary-criterion.astro";
import CalibrationVaryWeight from "@components/charts/calibration-vary-weight.astro";
import { getMarkets, getPlatforms, getCategories } from "@lib/api";

// Download markets and platforms
const markets = await getMarkets();
const platforms = await getPlatforms();
const categories = await getCategories();
---

<Base title="Calibration Charts">
  <div class="p-4 m-2">
    <h1 class="text-4xl font-bold">Calibration Charts</h1>
  </div>

  <div class="p-4 m-2">
    <div class="my-4">
      <h2 class="font-bold text-2xl" id="vary-selection">Basic Filtering</h2>
      <div class="my-2">
        Select markets to include in the calibration plot based on key
        attributes, such as number of traders, market volume, and duration.
        Alternatively, pick from a few other selection criteria.
      </div>
    </div>
    <CalibrationBase
      plotId="basic"
      platforms={platforms}
      options={[
        {
          icon: null,
          description: "Show all resolved markets.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets,
          criterion: null,
          weight: null,
        },
        {
          icon: null,
          description:
            "Filter to at least 10 traders or $100 in trade volume, and open for at least 2 days.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter((market) => {
            return (
              ((market.traders_count !== null && market.traders_count >= 10) ||
                (market.volume_usd !== null && market.volume_usd >= 100)) &&
              market.duration_days >= 2
            );
          }),
          criterion: null,
          weight: null,
        },
        {
          icon: null,
          description:
            "Filter to at least 100 traders or $1000 in trade volume, and open for at least 14 days.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter((market) => {
            return (
              ((market.traders_count !== null && market.traders_count >= 100) ||
                (market.volume_usd !== null && market.volume_usd >= 1000)) &&
              market.duration_days >= 14
            );
          }),
          criterion: null,
          weight: null,
        },
        {
          icon: null,
          description:
            "Filter to at least 1000 traders or $10,000 in trade volume, and open for at least 30 days.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter((market) => {
            return (
              ((market.traders_count !== null &&
                market.traders_count >= 1000) ||
                (market.volume_usd !== null && market.volume_usd >= 10000)) &&
              market.duration_days >= 30
            );
          }),
          criterion: null,
          weight: null,
        },
        {
          icon: null,
          description: "Filter to markets from the past year.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter(
            (market) =>
              new Date(market.close_datetime).getTime() >=
              new Date().getTime() - 365 * 24 * 60 * 60 * 1000,
          ),
          criterion: null,
          weight: null,
        },
        {
          icon: null,
          description: "Filter to markets that have been linked in questions.",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter((market) => market.question_id),
          criterion: null,
          weight: null,
        },
      ]}
    />
  </div>

  <div class="p-4 m-2">
    <div class="my-4">
      <h2 class="font-bold text-2xl" id="vary-category">Category Filtering</h2>
      <div class="my-2">
        Group markets based on what category they're in. This is determined by
        how they are categorized on each platforn, and not all platforms are
        supported yet.
      </div>
    </div>
    <CalibrationBase
      plotId="category"
      platforms={platforms}
      options={[
        {
          icon: "mdi:compass-rose",
          description: "All categories",
          axisTitleX: null,
          axisTitleY: null,
          markets: markets,
          criterion: null,
          weight: null,
        },
      ].concat(
        categories.map((category) => ({
          icon: category.icon,
          description: category.name,
          axisTitleX: null,
          axisTitleY: null,
          markets: markets.filter(
            (market) => market.category_slug == category.slug,
          ),
          criterion: null,
          weight: null,
        })),
      )}
    />
  </div>

  <div class="p-4 m-2">
    <div class="my-4">
      <h2 class="font-bold text-2xl" id="vary-prediction">
        Differing Predictions
      </h2>
      <div class="my-2">
        Up until this point we've used the midpoint of each market as the
        refrence value. What if we used something else, such as the average
        probability or a fixed point in time?
      </div>
    </div>
    <CalibrationVaryPrediction />
  </div>

  <div class="p-4 m-2">
    <div class="my-4">
      <h2 class="font-bold text-2xl" id="vary-prediction">Weighted Averages</h2>
      <div class="my-2">
        Typically all markets are trated equally with a raw average. What if we
        used a weighted average instead? For instance, markets with $100 in
        trade volume might be weighted 10 times as heavily as one with $10.
      </div>
    </div>
    <CalibrationVaryWeight />
  </div>
</Base>
